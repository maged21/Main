/* ================================================================
   GLOBAL MOUSE STATE
================================================================ */
let mouseX = 0;
let mouseY = 0;

document.addEventListener("mousemove", (e) => {
  mouseX = e.clientX / innerWidth;
  mouseY = e.clientY / innerHeight;
});


/* ================================================================
   GPU SHADER BACKGROUND â€” purple fog + distortion
================================================================ */
const bg = document.getElementById("bg");
const gl = bg.getContext("webgl");

function resizeBG() {
  bg.width = innerWidth;
  bg.height = innerHeight;
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
}
resizeBG();
addEventListener("resize", resizeBG);

// Vertex shader
const vs = `
attribute vec2 pos;
void main() {
  gl_Position = vec4(pos, 0., 1.);
}
`;

// Fragment shader (purple noise fog + mouse warp)
const fs = `
precision mediump float;

uniform float time;
uniform vec2 res;
uniform vec2 mouse;

float hash(vec2 p) { return fract(sin(dot(p, vec2(15.32, 45.12))) * 1523.21); }

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  float a = hash(i);
  float b = hash(i + vec2(1., 0.));
  float c = hash(i + vec2(0., 1.));
  float d = hash(i + vec2(1., 1.));
  vec2 u = f*f*(3.-2.*f);
  return mix(a, b, u.x) + (c - a)*u.y*(1. - u.x) + (d - b)*u.x*u.y;
}

void main() {
  vec2 uv = gl_FragCoord.xy / res;

  // Mouse warp ripple
  float dist = distance(uv, mouse);
  float warp = exp(-dist * 15.0) * 0.15;

  // Flowing distorted noise field
  float n = noise(uv * 6.0 + time * 0.05 + warp);

  // Fog mix
  vec3 dark = vec3(0.01, 0.0, 0.03); // almost black purple
  vec3 glow = vec3(0.4, 0.05, 0.7); // purple fog highlight

  vec3 col = mix(dark, glow, smoothstep(0.2, 1.0, n));

  gl_FragColor = vec4(col, 1.0);
}
`;

// Compile shader
function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

// Quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]),
  gl.STATIC_DRAW
);

const posLoc = gl.getAttribLocation(prog, "pos");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uTime = gl.getUniformLocation(prog, "time");
const uRes = gl.getUniformLocation(prog, "res");
const uMouse = gl.getUniformLocation(prog, "mouse");

function render(t) {
  gl.uniform1f(uTime, t * 0.001);
  gl.uniform2f(uRes, bg.width, bg.height);
  gl.uniform2f(uMouse, mouseX, 1.0 - mouseY);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
render(0);


/* ================================================================
   DOT GRID (with mouse wave)
================================================================ */
const dots = document.getElementById("bg-dots");
const ctx = dots.getContext("2d");

function resizeDots() {
  dots.width = innerWidth;
  dots.height = innerHeight;
}
resizeDots();
addEventListener("resize", resizeDots);

function drawDots() {
  ctx.clearRect(0, 0, dots.width, dots.height);

  const gap = 60;
  ctx.fillStyle = "rgba(255,255,255,0.06)";

  for (let x = 0; x < dots.width; x += gap) {
    for (let y = 0; y < dots.height; y += gap) {

      // small warp ripple from mouse
      const dx = (mouseX - 0.5) * (x - dots.width/2) * 0.0008;
      const dy = (mouseY - 0.5) * (y - dots.height/2) * 0.0008;

      ctx.beginPath();
      ctx.arc(x + dx, y + dy, 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  requestAnimationFrame(drawDots);
}
drawDots();


first one 

/* ================================================================
   GLOBAL MOUSE STATE
================================================================ */
let mouseX = 0;
let mouseY = 0;

document.addEventListener("mousemove", (e) => {
  mouseX = e.clientX / innerWidth;
  mouseY = e.clientY / innerHeight;
});


/* ================================================================
   GPU SHADER BACKGROUND â€” purple fog + distortion
================================================================ */
const bg = document.getElementById("bg");
const gl = bg.getContext("webgl");

function resizeBG() {
  bg.width = innerWidth;
  bg.height = innerHeight;
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
}
resizeBG();
addEventListener("resize", resizeBG);

// Vertex shader
const vs = `
attribute vec2 pos;
void main() {
  gl_Position = vec4(pos, 0., 1.);
}
`;

const fs = `
precision highp float;

uniform float time;
uniform vec2 res;
uniform vec2 mouse;

// hash
float hash(vec2 p) {
  return fract(sin(dot(p, vec2(41.31, 89.13))) * 83758.5453);
}

// smooth noise
float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);

  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));

  vec2 u = f * f * (3.0 - 2.0 * f);

  return mix(a, b, u.x) +
         (c - a) * u.y * (1.0 - u.x) +
         (d - b) * u.x * u.y;
}

// fractal noise
float fbm(vec2 p) {
  float v = 0.0;
  float a = 0.5;

  for (int i = 0; i < 6; i++) {
    v += a * noise(p);
    p *= 2.1;
    a *= 0.48;
  }
  return v;
}

void main() {
  vec2 uv = gl_FragCoord.xy / res.xy;
  uv -= 0.5;

  // fix aspect ratio
  uv.x *= res.x / res.y;

  // mouse turbulence
  float m = distance(uv, (mouse - 0.5) * vec2(1.0, -1.0)) * 2.0;
  float mouseWarp = exp(-m * 3.0) * 0.3;

  // organic swirl motion
  float t = time * 0.15;
  vec2 flow = uv;

  flow.x += sin(uv.y * 3.0 + t) * 0.05;
  flow.y += cos(uv.x * 3.0 - t * 0.6) * 0.05;

  // fade swirl into noise based on distance
  flow += mouseWarp * 0.15;

  float n = fbm(flow * 2.5 + t * 0.4);

  // color palette (soft purple nebula)
  vec3 dark = vec3(0.01, 0.0, 0.03);
  vec3 glow = vec3(0.55, 0.1, 0.8);

  // map noise
  float fog = smoothstep(0.25, 1.0, n);

  // final color
  vec3 col = mix(dark, glow, fog);

  gl_FragColor = vec4(col, 1.0);
}
`;

// Compile shader
function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

// Quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]),
  gl.STATIC_DRAW
);

const posLoc = gl.getAttribLocation(prog, "pos");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uTime = gl.getUniformLocation(prog, "time");
const uRes = gl.getUniformLocation(prog, "res");
const uMouse = gl.getUniformLocation(prog, "mouse");

function render(t) {
  gl.uniform1f(uTime, t * 0.001);
  gl.uniform2f(uRes, bg.width, bg.height);
  gl.uniform2f(uMouse, mouseX, 1.0 - mouseY);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
render(0);


/* ================================================================
   DOT GRID (with mouse wave)
================================================================ */
const dots = document.getElementById("bg-dots");
const ctx = dots.getContext("2d");

function resizeDots() {
  dots.width = innerWidth;
  dots.height = innerHeight;
}
resizeDots();
addEventListener("resize", resizeDots);

function drawDots() {
  ctx.clearRect(0, 0, dots.width, dots.height);

  const gap = 60;
  ctx.fillStyle = "rgba(255,255,255,0.06)";

  for (let x = 0; x < dots.width; x += gap) {
    for (let y = 0; y < dots.height; y += gap) {

      // small warp ripple from mouse
      const dx = (mouseX - 0.5) * (x - dots.width/2) * 0.0008;
      const dy = (mouseY - 0.5) * (y - dots.height/2) * 0.0008;

      ctx.beginPath();
      ctx.arc(x + dx, y + dy, 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  requestAnimationFrame(drawDots);
}
drawDots();


second one 


const fs = `
precision highp float;

uniform float time;
uniform vec2 res;
uniform vec2 mouse;

float blob(vec2 p, vec2 center, float size) {
  float d = length(p - center);
  return smoothstep(size, 0.0, d);
}

void main() {
  vec2 uv = gl_FragCoord.xy / res.xy;
  uv -= 0.5;
  uv.x *= res.x / res.y;

  // Animated blob centers
  vec2 c1 = vec2(sin(time*0.4)*0.3, cos(time*0.3)*0.2);
  vec2 c2 = vec2(cos(time*0.2)*0.25, sin(time*0.5)*0.3);
  vec2 c3 = vec2(sin(time*0.3+1.0)*0.35, cos(time*0.4+2.0)*0.25);

  // Mouse repulsion
  vec2 mousePos = (mouse - 0.5) * vec2(1.0, -1.0);
  float repulse = exp(-length(uv - mousePos) * 5.0) * 0.5;

  float b =
    blob(uv + repulse * (uv - mousePos), c1, 0.35) +
    blob(uv + repulse * (uv - mousePos), c2, 0.25) +
    blob(uv + repulse * (uv - mousePos), c3, 0.3);

  b = clamp(b, 0.0, 1.0);

  vec3 colA = vec3(0.05, 0.0, 0.1);
  vec3 colB = vec3(0.6, 0.2, 0.9);

  vec3 col = mix(colA, colB, b);

  gl_FragColor = vec4(col, 1.0);
}
`;



third fs

ðŸŽ¨ THE PURPLE COLOR SECTION (THIS creates the purple fog)

Inside your fragment shader (fs), this piece:

vec3 dark = vec3(0.01, 0.0, 0.02);
vec3 tint = vec3(0.25, 0.05, 0.35);

vec3 col = mix(dark, tint, b * 0.55);

gl_FragColor = vec4(col, 1.0);

âœ” dark = background base color

Right now:
0.01, 0.0, 0.02 â†’ very dark purple

âœ” tint = blob color tone

Right now:
0.25, 0.05, 0.35 â†’ soft lavender/purple

âœ” mix(dark, tint, b * 0.55)

This blends:

blackâ€“purple background (dark)

purple blob color (tint)

based on blob intensity b

The value 0.55 controls how strong the purple becomes.

â­ If you simply want to change the purple shade, edit tint:

Examples:

ðŸ”µ More blue:
vec3 tint = vec3(0.1, 0.15, 0.4);

ðŸ’œ Stronger purple:
vec3 tint = vec3(0.45, 0.15, 0.55);

ðŸŽ€ Pinkish:
vec3 tint = vec3(0.55, 0.1, 0.35);

âš« Almost no purple (super subtle):
vec3 tint = vec3(0.12, 0.02, 0.15);

â­ If you want blobs to be visible more, increase mixing:
vec3 col = mix(dark, tint, b * 0.75);


More purple, more contrast.

â­ If you want background darker or lighter, change dark:
Lighter:
vec3 dark = vec3(0.05, 0.02, 0.07);

Full black:
vec3 dark = vec3(0.0, 0.0, 0.0);

